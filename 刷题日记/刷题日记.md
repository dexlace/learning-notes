# 刷题日记

烦啊，我可能不仅仅没理解编程这回事儿，如果仅仅是学很多框架，很多技术栈，我想还是很浪费时间，因为没有真正的具体项目经验，

反而是算法这东西很重要，是区分你是否能吃这行饭的唯一途径；但是刷题有用吗？有吧？但是刷题你会忘啊，怎么办？烦？我不承认自

己是小白，但是我题都不刷，真的太过分了。

## 20210402



### 1.两个栈实现队列

[剑指offer 09]: https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/

<img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210402203652540.png" alt="image-20210402203652540" style="zoom:80%;" />

垃圾如我，很久才对这样的输入示例看懂，实在是想死。

```java
class CQueue {

    Stack <Integer> stackIn;
    Stack <Integer> stackOut;

    public CQueue() {
      stackIn=new Stack<Integer>();
      stackOut=new Stack<Integer>();

    }
    
    public void appendTail(int value) {

        // stackIn 的栈顶就是队列的尾部
        // 如果永远不delete，或者查询，stackOut应该是永远为空
        stackIn.push(value);

    }
    
    public int deleteHead() {
        // stackOut取栈顶为队列的头部
        // 一旦要头部信息，就需要把stackIn出栈，并且存放至stackOut
        if(!stackOut.empty()){
            return stackOut.pop();
        }else{
            if(stackIn.empty())
                return -1;
            while(!stackIn.empty()){
                 stackOut.push(stackIn.pop());
            }
                return stackOut.pop();
        }       
    }
}

```

### 2. 栈中的最小元素

[包含min函数的栈]: https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/

```java
class MinStack {

    Stack <Integer> stackIn;
    
    Stack <Integer> stackOut;


    /** initialize your data structure here. */
    public MinStack() {
      stackIn=new Stack<Integer>();
      stackOut=new Stack<Integer>() ;
    }
    
    // 压栈
    // 并更新最小值
    public void push(int x) {
        stackIn.push(x);
        // 维持着从栈顶到栈底的递增
        if(stackOut.empty() || stackOut.peek() >= x)
            stackOut.push(x);

    }
    
    // 弹出最顶层元素
    // 并更新最小值
    // 弹出的元素如果是最小值,则两边都要弹出
    public void pop() {
       if((stackIn.pop()).equals(stackOut.peek()))
            stackOut.pop();
       
    }
    
    // 返回最顶层元素
    public int top() {
        return stackIn.peek();

    }
    
    public int min() {
        return stackOut.peek();
    }
}
```

